{"code":"!function(e){var n={};function s(t){if(n[t])return n[t].exports;var i=n[t]={i:t,l:!1,exports:{}};return e[t].call(i.exports,i,i.exports,s),i.l=!0,i.exports}s.m=e,s.c=n,s.d=function(e,n,t){s.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},s.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},s.t=function(e,n){if(1&n&&(e=s(e)),8&n)return e;if(4&n&&\"object\"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,\"default\",{enumerable:!0,value:e}),2&n&&\"string\"!=typeof e)for(var i in e)s.d(t,i,function(n){return e[n]}.bind(null,i));return t},s.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(n,\"a\",n),n},s.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},s.p=\"\",s(s.s=\"./app/app.js\")}({\"./app/app.js\":\n/*!********************!*\\\n  !*** ./app/app.js ***!\n  \\********************/\n/*! no static exports found */function(module,exports,__webpack_require__){eval('__webpack_require__ (/*! ./game.js */ \"./app/game.js\")\\n\\nclass Session {\\n  constructor() {\\n    this.game;\\n    this.canvas;\\n    this.globalTimer;\\n    this.resourcesDisplay;\\n  }\\n\\n  initialize() {\\n    this.game = new Clempire();\\n    this.game.load.then(function () {\\n      window.addEventListener(\\'resize\\', this.resizeHandler(), true);\\n      this.drawGame();\\n      this.displayResources();\\n      this.startGame();\\n    }.bind(this));\\n  }\\n\\n  resizeHandler() {\\n    let context = {\\n      session: this,\\n      // wait 100ms for further resizing \\n      delta: 100,\\n      timeout: false\\n    }\\n    return function() {\\n      console.log(context)\\n      context.rtime = new Date();\\n      if (!context.timeout) {\\n        context.timeout = true;\\n        setTimeout(context.session.resizeEnd.bind(context), context.delta);\\n      }\\n    }\\n  }\\n\\n  resizeEnd() {\\n    console.log(this)\\n    if (new Date() - this.rtime < this.delta) {\\n      setTimeout(this.session.resizeEnd.bind(this), this.delta);\\n    } else {\\n      this.timeout = false;\\n      this.session.drawGame.apply(this.session);\\n    }\\n  }\\n\\n  drawGame() {\\n    this.canvas = document.getElementById(\"mainCanvas\");\\n    let leftSide = document.getElementById(\"left-side\");\\n    this.canvas.width = leftSide.offsetWidth;\\n    this.canvas.height = leftSide.offsetHeight;\\n    this.displaySources();\\n    this.displayBuildings();\\n  }\\n\\n  startGame() {\\n    this.globalTimer = setInterval(this.tick.bind(this), 200);\\n  }\\n\\n  tick() {\\n    this.updateResources();\\n  }\\n\\n  displaySources() {\\n    let context = this.canvas.getContext(\"2d\");\\n    this.placeResourceAnchors();\\n    let resourceFields = document.getElementsByClassName(\"resource-field\");\\n    let counter = 0;\\n    let topGridSize = this.canvas.height / (resourceFields.length + 1)\\n\\n    for (let source in this.game.sourcesData) {\\n      if (counter === resourceFields.length) {\\n        throw new Error(\"Not enogh resource fields!\")\\n      }\\n      let image = new Image();\\n      // ToDo: cache image... atm this is reloading on every resize\\n      image.onload = function () {\\n        context.drawImage(image, 0, 0, image.width, image.height, this.canvas.width * 0.5 - 85, this.topGridSize * (this.counter + 1) - 85, 170, 170);\\n      }.bind({\\n        canvas: this.canvas,\\n        counter: counter,\\n        topGridSize: topGridSize\\n      })\\n      image.src = this.game.sourcesData[source].img;\\n      let field = resourceFields[counter];\\n      field.onclick = this.game.fieldClick.bind(this.game.sourcesData[source]);\\n      counter++;\\n    }\\n  }\\n\\n  placeResourceAnchors() {\\n    let count = 1;\\n    let length = this.game.sourcesData.length;\\n    let anchors = document.getElementById(\"anchors\");\\n    while (anchors.firstChild) {\\n      anchors.removeChild(anchors.firstChild);\\n    }\\n    for (let source in this.game.sourcesData) {\\n      let anchor = document.createElement(\"div\");\\n      anchor.classList.add(\"resource-field-anchor\");\\n      anchor.setAttribute(\"data-source-field\", count.toString());\\n      anchor.style.top = `${(100 / (length + 1)) * count}%`;\\n      anchor.style.left = \"50%\";\\n      let field = document.createElement(\"div\");\\n      field.classList.add(\"resource-field\");\\n      field.style.cursor = `url(${this.game.sourcesData[source].cursor}), pointer`\\n      anchor.appendChild(field);\\n      anchors.appendChild(anchor);\\n      count++;\\n    }\\n  }\\n\\n  displayResources() {\\n    this.resourcesDisplay = document.querySelector(\"#resources ul\");\\n    // clear list in case of a redraw due to window resize or new resources\\n    while (this.resourcesDisplay.firstChild) {\\n      this.resourcesDisplay.removeChild(this.resourcesDisplay.firstChild);\\n    }\\n    for (let resource in this.game.resourcesData) {\\n      let display = document.createElement(\"li\");\\n      let label = document.createElement(\"div\");\\n      label.style.background = `url(${this.game.resourcesData[resource].icon})  no-repeat`;\\n      display.appendChild(label);\\n      let count = document.createElement(\"span\");\\n      count.classList.add(\"resource-count\");\\n      display.appendChild(count);\\n      display.setAttribute(\"data-resource\", resource);\\n      this.resourcesDisplay.appendChild(display);\\n    }\\n  }\\n\\n  displayBuildings() {\\n    this.buildingsDisplay = document.getElementById(\"buildings\");\\n    // clear list in case of a redraw due to window resize or new resources\\n    while (this.buildingsDisplay.firstChild) {\\n      this.buildingsDisplay.removeChild(this.buildingsDisplay.firstChild);\\n    }\\n    for (let buildingIndex in this.game.buildingsData) {\\n      let display = document.createElement(\"div\");\\n      let building = this.game.buildingsData[buildingIndex];\\n      display.style.background = `url(${building.icon})  no-repeat`;\\n      display.setAttribute(\"title\", `${building.title}\\\\n\\\\n${building.description}`)\\n      this.buildingsDisplay.appendChild(display);\\n    }\\n  }\\n\\n  updateResources() {\\n    for (let i = 0; i < this.resourcesDisplay.children.length; i++) {\\n      let resourceDisplay = this.resourcesDisplay.children[i];\\n      resourceDisplay.getElementsByTagName(\"span\")[0].innerText = this.game.resources.current[resourceDisplay.dataset.resource];\\n    }\\n  }\\n}\\n\\nlet session = new Session();\\nwindow.addEventListener(\"load\", session.initialize.bind(session), true);\\n\\n//# sourceURL=webpack:///./app/app.js?')},\"./app/audio.js\":\n/*!**********************!*\\\n  !*** ./app/audio.js ***!\n  \\**********************/\n/*! no static exports found */function(module,exports){eval(\"class AudioPlayer {\\n  constructor() {\\n    this.sounds = {};\\n    try {\\n      // Fix up for prefixing\\n      window.AudioContext = window.AudioContext || window.webkitAudioContext;\\n      this.audioContext = new AudioContext();\\n      if (window.Worker) {\\n        this.worker = new Worker(\\\"soundWorker.js\\\")\\n        this.worker.onmessage = function (e) {\\n          this.audioContext.decodeAudioData(e.data.response, function (buffer) {\\n            this.sounds[e.data.id].buffer = buffer;\\n          }.bind(this), this.onError);\\n        }.bind(this);\\n      } else {\\n        console.log('Your browser doesn\\\\'t support web workers.')\\n      }\\n    } catch (e) {\\n      alert('Web Audio API is not supported in this browser\\\\n\\\\nThis game will not have any sounds :(');\\n      this.audioContext = undefined;\\n    }\\n  }\\n\\n  addSound(id, url) {\\n    if (!this.audioContext) return;\\n    this.sounds[id] = new Sound(url, id);\\n    this.sounds[id].prepare(this.worker, this.audioContext);\\n  }\\n\\n  playSound(id) {\\n    if (!this.audioContext) return;\\n    let sound = this.sounds[id];\\n    let source = this.audioContext.createBufferSource();\\n    source.buffer = sound.buffer;\\n    source.connect(this.audioContext.destination);\\n    source.start(0);\\n  }\\n\\n  onError(error) {\\n    console.log(\\\"Error while loading a sound\\\")\\n    console.log(error)\\n  }\\n}\\n\\nclass Sound {\\n  constructor(url, id) {\\n    this.sourceURL = url;\\n    this.id = id;\\n    this.buffer = undefined;\\n  }\\n\\n  prepare(worker, audioContext) {\\n    if (!worker) return;\\n    worker.postMessage({\\n      id: this.id,\\n      url: this.sourceURL\\n    })\\n  }\\n}\\n\\nmodule.exports = {\\n  AudioPlayer,\\n  Sound\\n};\\n\\n//# sourceURL=webpack:///./app/audio.js?\")},\"./app/game.js\":\n/*!*********************!*\\\n  !*** ./app/game.js ***!\n  \\*********************/\n/*! no static exports found */function(module,exports,__webpack_require__){eval('__webpack_require__ (/*! ./audio.js */ \"./app/audio.js\")\\n\\nclass Clempire {\\n  constructor(session) {\\n    this.audio = new AudioPlayer();\\n    this.load = new Promise(function (resolve, reject) {\\n      let now = (new Date).getTime();\\n      console.log(\"Loading data ...\");\\n      this.loadData().then(function () {\\n        this.resources = {\\n          produced: {},\\n          gathered: {},\\n          current: {}\\n        };\\n        for (let type in this.resources) {\\n          for (let resource in this.resourcesData) {\\n            this.resources[type][resource] = 0;\\n          }\\n        }\\n        console.log(`... done in ${((new Date()).getTime() - now)}ms`);\\n        resolve()\\n      }.bind(this));\\n    }.bind(this));\\n  }\\n\\n  async loadData() {\\n    let loadingResources = fetch(\"/assets/data/resources.json\")\\n      .catch(e => console.log(e))\\n      .then(response => response.json());\\n    let loadingBuildings = fetch(\"/assets/data/buildings.json\")\\n      .catch(e => console.log(e))\\n      .then(response => response.json());\\n    let loadingSources = fetch(\"/assets/data/sources.json\")\\n      .catch(e => console.log(e))\\n      .then(response => response.json());\\n    [this.resourcesData, this.buildingsData, this.sourcesData] = await Promise.all([loadingResources, loadingBuildings, loadingSources]);\\n    for (let source in this.sourcesData) {\\n      this.audio.addSound(this.sourcesData[source].id, this.sourcesData[source].sound);\\n    }\\n  }\\n\\n  fieldClick() {\\n    // called for a click on a resource field.\\n    // this is binded to the clicked resource object\\n    session.game.resources.current[this.id]++;\\n    session.game.resources.gathered[this.id]++;\\n    session.game.audio.playSound(this.id);\\n  }\\n\\n  isReqMet(req) {\\n    for (let category in req.resources) {\\n      for (let resource in this.resourcesData) {\\n        if(!req.resources[category][resource] || req.resources[category][resource] > this.resources[category][resource]) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\\nclass Requirement {\\n  constructor() {\\n    this.resources = {\\n      produced: {},\\n      gathered: {},\\n      total: {}\\n    }\\n  }\\n}\\n\\nmodule.exports = {\\n  Clempire,\\n  Requirement\\n};\\n\\n//# sourceURL=webpack:///./app/game.js?')}});","extractedComments":[]}